## TCP
>简单来说 TCP协议的作用就是保证数据通信的完整性和可靠性，防止丢包。 比如说缓存满了新进来的数据包就会丢失，如果需要发现丢了哪一个包以及如何重新发送这个包，就依靠TCP协议
* 服务器发送数据，有许多原因会导致丢包，所以在线路允许的情况下达到最大速率，需要慢慢试，所以TCP设计了慢启动机制，开始的时候发送的比较慢，根据丢包情况调整速率
#### 三次握手和四次挥手
![](https://img-blog.csdn.net/20180717202520531?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

>三次握手解决的本质是，信道不可靠，双方确认信息：三次通信是理论上的最小值；所以三次握手是满足在不可靠的信道上可靠的传输信息。详情可见 <a href="https://groups.google.com/forum/#!topic/pongba/kF6O7-MFxM0/discussion" target="_blank">TCP为什么需要三次握手</a>
* 第一次握手：建立连接时，客户端发送SYN包(SYN=1, seq=随机一个32位长的序列号X)；然后客户端进入SYN_SEND状态等待服务器确认
* 第二次握手：服务器收到SYN报文段进行确认，设置ack=Z=X(接受到seq的值)+1；同事自己要发送SYN请求信息，SYN=1，seq=Y(随机一个32位长的序列号)，服务器将所有信息（SYN+ACK包）发送到客户端，服务器进入SYN_RECV状态
* 第三次握手：客户端接收到报文段（SYN+ACK包），将ack=Y+1, seq=Z(接收到的ack的值)+1;向服务器发送包ACK，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手

##### 个人白话理解如下
* A向B发一个随机X
* B接收到X，B做出X+1是准备告诉A，B能识别A传来的数据，同时B传给A一个随机Y
* A接收到Y，同时给B传输Y+1告诉B，A能识别B的数据，接下来可以进行数据传输并且达到双方有效接收

![](https://img-blog.csdn.net/20180717204202563?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

>关闭时四次握手，主要是在关闭链接时，服务器收到FIN报文时，很可能不会立即关闭SOCKET，所以只先回复ACK报文，告诉客户端，你的FIN报文我收到了，等到服务器所有报文都发送完了，才能发送FIN报文。所以比建立链接时多一步

## HTTPS
**主要解决用户向A请求到的内容没有被人篡改**
>HTTP下增加SLL/TLS层，传输的内容都是加密的防篡改、窃听
* 采用 非对称加密 + 对称加密 配合使用
* 客户端发送HTTPS请求
* 服务端下发经过认证的证书，证书内包含颁发机构、过期时间、公钥A等
* 客户端收到验证证书信息后，生成一个秘钥B(对称加密方法的秘钥)，通过证书中服务端下发的公钥A加密后传输给服务端
* 服务端使用私钥(可以解析公钥B的私钥 -- 非对称加密)解密，获得客户端生成的秘钥B，后续客户端和服务端通信就可以用A作为秘钥，把内容进行对称加密进行通信

## HTTP2.0 比较于 HTTP1.x
* HTTP2.是对之前HTTP标准的扩展，应用语义例如方法、状态代码、标头字段等核心概念保持不变
* 新增二进制分帧层，HTTP1.x协议以文本传输、头部包含cookie等信息传输成本过大，HTTP2.x进行HPACK压缩格式
   * 减少传输包体积大小
   * 客户端和服务端同事更新维护一个标头信息索引列表，后续通信只需要传输索引值和差异标头(客户端和服务端在同时维护索引)
* 服务端推送
   * 服务器对客户端一个请求可以发送多个响应 -> 服务端除了回复必须的响应，还可以主动推送额外资源(比如获取到HTTP其实可以直接推送依赖图片等)
* 请求和响应的复用
   * 同一个链接可以并行多个数据传输，在另一端进行重新组装
   * 数据流增加优先级区分保证顺序
   * 服务器的一个来源仅需要一个链接，减少链接数量和会话的重用率

